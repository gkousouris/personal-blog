{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/geometric-deep-learning-overview/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Jedr Blaszyk - Blog","author":"Jedr Blaszyk"}},"markdownRemark":{"id":"24ca9261-45c2-548c-8120-581b8d19ee9a","html":"<ul>\n<li><a href=\"#non-euclidean-domains\">Non-Euclidean domains</a></li>\n<li><a href=\"#spectral-methods\">Spectral methods</a></li>\n<li><a href=\"#spatial-methods\">Spatial methods</a></li>\n<li><a href=\"#why-spatial-is-better-than-spectral\">Why spatial is better than spectral</a></li>\n<li><a href=\"#introduction-by-example:-gcn-implemented-in-pytorch-geometric\">Introduction by example: GCN implemented in PyTorch Geometric</a></li>\n</ul>\n<p><img src=\"/85abcdbfed15a1b12189f3be8c49d42a/gdl.gif\" alt=\"Intro image GLD\"></p>\n<p>I decided to write a series of articles to cover the things I’ve learned while working on my MEng thesis. My work is focused on applying Geometric Deep Learning methods for shape analysis in the medical setting. The first post is an overview of Geometric Deep Learning.</p>\n<p><strong>Geometric deep learning (GDL)</strong>, a term first proposed by Bronstein et al. <a href=\"#references\">[1]</a>, has emerged aiming to generalize deep learning models to non-Euclidean domains. This novel field in the world of machine learning was successfully used for building recommender systems <a href=\"#references\">[2]</a>, protein function prediction <a href=\"#references\">[3]</a>, fake news detection <a href=\"#references\">[4]</a>, and detection of cancer-beating molecules in food <a href=\"#references\">[5]</a>. GDL owes its success to the fact that it operates directly on the relational structure of a given problem. An example of such a structure is a graph. It can describe various concepts ranging from a social network to a chemical compound.</p>\n<p>Most GNN architectures are based on message passing (spatial methods), where at each layer the nodes update\ntheir hidden representations by aggregating information they collect from their neighbours. A crucial difference from traditional neural networks operating on grid-structured data is the absence of canonical ordering of the nodes in a graph. To address this, usually the aggregation function is constructed to be invariant to neighbourhood permutations.</p>\n<h2 id=\"non-euclidean-domains\" style=\"position:relative;\"><a href=\"#non-euclidean-domains\" aria-label=\"non euclidean domains permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-Euclidean domains</h2>\n<p><strong>Graph.</strong> A graph G is a pair <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(V,E)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span></span> with the finite set of vertices <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span></span> and edges <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span>. It captures interactions (edges) between individual units (nodes).</p>\n<p><strong>Manifold.</strong> A manifold is a is a locally Euclidean space. In computer graphics, shapes are represented as discrete 2-dimensional manifolds. A discrete manifold has vertices uniformly sampled from the surface of the manifold with edges expressing the local structure of the shape. It’s commonly called a triangular mesh.</p>\n<h2 id=\"spectral-methods\" style=\"position:relative;\"><a href=\"#spectral-methods\" aria-label=\"spectral methods permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spectral methods</h2>\n<p>Spectral methods were the first approach to generalize convolution operation to non-Euclidean domains. In practice, they are rarely used because they are computationally inefficient and don’t generalize well to different domains.</p>\n<p>Spectral graph convolution draws inspiration from the Euclidean convolution in a spectral domain. The Fourier basis is used to compute spectral convolution in the classical signal processing (Read <a href=\"https://www-structmed.cimr.cam.ac.uk/Course/Convolution/convolution.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">this</a> for an in-depth explanation of Convolution theorem). Given a graph, one way to generalize a convolutional architecture is to look at linear operators that commute with the graph Laplacian. This property implies operating on the spectrum of the graph weights, given by the eigenvectors of the graph Laplacian. The concept of graph convolution is explained more in-depth <a href=\"https://towardsdatascience.com/spectral-graph-convolution-explained-and-implemented-step-by-step-2e495b57f801\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">in here</a>.</p>\n<h2 id=\"spatial-methods\" style=\"position:relative;\"><a href=\"#spatial-methods\" aria-label=\"spatial methods permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spatial methods</h2>\n<p>Spatial methods are preferred over the spectral methods for <a href=\"#why-spatial-is-better-than-spectral\">a number of reasons</a>. The spatial convolution is considered a more versatile method for learning on non-Euclidean structures.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1fbbb698e41ac0c21c7e7f9a30ecf300/3ac88/comparison_2d_graph.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdu4QD//xAAWEAADAAAAAAAAAAAAAAAAAAABEEH/2gAIAQEAAQUCpX//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAXEAEBAQEAAAAAAAAAAAAAAAAAITGR/9oACAEBAAE/Ib2wr//aAAwDAQACAAMAAAAQc8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAaEAADAAMBAAAAAAAAAAAAAAAAAREhMUFh/9oACAEBAAE/EEs1c9FaOCfFZ//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Convolution on an 2D image vs. on a graph\"\n        title=\"Convolution on an 2D image vs. on a graph\"\n        src=\"/static/1fbbb698e41ac0c21c7e7f9a30ecf300/a2510/comparison_2d_graph.jpg\"\n        srcset=\"/static/1fbbb698e41ac0c21c7e7f9a30ecf300/0479a/comparison_2d_graph.jpg 250w,\n/static/1fbbb698e41ac0c21c7e7f9a30ecf300/41099/comparison_2d_graph.jpg 500w,\n/static/1fbbb698e41ac0c21c7e7f9a30ecf300/a2510/comparison_2d_graph.jpg 1000w,\n/static/1fbbb698e41ac0c21c7e7f9a30ecf300/3ac88/comparison_2d_graph.jpg 1260w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<em>Figure 1: 2D Convolution vs. Graph Convolution.</em></p>\n<p>Spatial methods define graph convolutions based on a node’s spatial relations, which is analogous to the convolution operation on the classical CNN. Images can be considered a special form of a graph with each pixel representing a node, connected to each neighboring pixels. A filter would be applied on the patch of the image including the pixel and its neighboring nodes. Similarly, spatial methods convolve a given node’s features, using a patch operator, with its neighbors’ features. The intuition about the spatial graph convolutions is that this operation propagates and updates node features along edges.</p>\n<h2 id=\"why-spatial-is-better-than-spectral\" style=\"position:relative;\"><a href=\"#why-spatial-is-better-than-spectral\" aria-label=\"why spatial is better than spectral permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why spatial is better than spectral</h2>\n<p>Spatial models are preferred over spectral models due to efficiency, generality, and flexibility issues. Spectral models are less efficient than spatial models as they need to perform eigendecomposition or handle the whole graph at the same time (e.g. mesh completion scenario). Spatial models are more scalable to large graphs as they directly perform convolutions in the graph domain via information propagation (i.e. message passing). The computation can be performed in a batch of nodes instead of the whole graph. Moreover, spectral models assume a fixed graph and because they rely on a graph Fourier basis they generalize poorly to new graphs. This is because any perturbation to a graph results in a change of eigenbasis. Spatial models perform graph convolutions locally on each node, which allows for weight sharing across different structures and locations. Finally, spectral methods are limited to undirected graphs whereas spatial methods can handle a bigger variety of graphs such as edge inputs, directed graphs, signed graphs and heterogeneous graphs because of the flexibility of the aggregation function</p>\n<h2 id=\"introduction-by-example-gcn-implemented-in-pytorch-geometric\" style=\"position:relative;\"><a href=\"#introduction-by-example-gcn-implemented-in-pytorch-geometric\" aria-label=\"introduction by example gcn implemented in pytorch geometric permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction by example: GCN implemented in PyTorch Geometric</h2>\n<p><strong>PyTorch Geometric</strong> <a href=\"#references\">[6]</a> is a geometric deep learning extension library for PyTorch. It is a library for deep learning on irregularly structured input data such as graphs, point clouds, and manifolds, also known as geometric deep learning, from a variety of published papers. It consists of an easy-to-use mini-batch loader for many small and single big graphs, multi gpu-support and a large number of common benchmark datasets.</p>\n<p>PyTorch Geometric makes use of Generic Message Passing Scheme to implement any convolutional operator. The message passing scheme consists of 2 steps:</p>\n<ul>\n<li>propagate step - messages from nodes are propagated to their local neighborhoods.</li>\n<li>update step - embedded node’s features are updated by the message vector.</li>\n</ul>\n<p><strong>Graph Convolutional Network (GCN)</strong> was defined by Kipf et al. <a href=\"#references\">[7]</a>. The intuition of this method is that it can alleviate the problem of overfitting on local neighborhood structures for graphs with very wide node degree distributions, such as social networks, citation networks, and many other real-world graph datasets. The computational complexity of this approach is <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span></span>. It applies simple filters acting on the 1-hop neighborhood of the graph in the spatial domain. It can be expressed in the generic message-passing scheme as:</p>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>msg</mtext><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><msqrt><mrow><mi>deg</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></msqrt><mo>⋅</mo><msqrt><mrow><mi>d</mi><mi>e</mi><mi>g</mi><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow></msqrt></mrow></mfrac><mo>⋅</mo><mrow><mo fence=\"true\">(</mo><msub><mi mathvariant=\"bold\">x</mi><mi>j</mi></msub><mi mathvariant=\"bold\">Θ</mi><mo fence=\"true\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">\\text{msg}(x_i, x_j) =  \\frac{1}{\\sqrt{\\deg(x_i)} \\cdot \\sqrt{deg(x_j)}} \\cdot \\left( \\mathbf{x}_j\\mathbf{\\Theta} \\right)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord text\"><span class=\"mord\">msg</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.469494em;vertical-align:-1.1480540000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.175em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.935em;\"><span class=\"svg-align\" style=\"top:-3.2em;\"><span class=\"pstrut\" style=\"height:3.2em;\"></span><span class=\"mord\" style=\"padding-left:1em;\"><span class=\"mop\">de<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span><span style=\"top:-2.8950000000000005em;\"><span class=\"pstrut\" style=\"height:3.2em;\"></span><span class=\"hide-tail\" style=\"min-width:1.02em;height:1.28em;\"><svg width=\"400em\" height=\"1.28em\" viewBox=\"0 0 400000 1296\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M263,681c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl0 -0\nc4.7,-7.3,11,-11,19,-11\nH40000v40H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM1001 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30499999999999994em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.916946em;\"><span class=\"svg-align\" style=\"top:-3.2em;\"><span class=\"pstrut\" style=\"height:3.2em;\"></span><span class=\"mord\" style=\"padding-left:1em;\"><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span><span style=\"top:-2.8769460000000002em;\"><span class=\"pstrut\" style=\"height:3.2em;\"></span><span class=\"hide-tail\" style=\"min-width:1.02em;height:1.28em;\"><svg width=\"400em\" height=\"1.28em\" viewBox=\"0 0 400000 1296\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M263,681c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl0 -0\nc4.7,-7.3,11,-11,19,-11\nH40000v40H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM1001 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32305399999999995em;\"><span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1480540000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">x</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathbf\">Θ</span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span></span></span></span></span></div>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><msup><mi mathvariant=\"bold\">x</mi><mo mathvariant=\"bold\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mi>i</mi></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>j</mi><mo>∈</mo><mi mathvariant=\"script\">N</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>∪</mo><mo stretchy=\"false\">{</mo><mi>i</mi><mo stretchy=\"false\">}</mo></mrow></munder><mtext>msg</mtext><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>x</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbf{x'}_i = \\sum_{j \\in \\mathcal{N}(i) \\cup \\{ i \\}} \\text{msg}(x_i, x_j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9518920000000001em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbf\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.801892em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathbf mtight\">′</span></span></span></span></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.5660100000000003em;vertical-align:-1.516005em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.050005em;\"><span style=\"top:-1.808995em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">∈</span><span class=\"mord mtight\"><span class=\"mord mathcal mtight\" style=\"margin-right:0.14736em;\">N</span></span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">∪</span><span class=\"mopen mtight\">{</span><span class=\"mord mathdefault mtight\">i</span><span class=\"mclose mtight\">}</span></span></span></span><span style=\"top:-3.0500049999999996em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.516005em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord text\"><span class=\"mord\">msg</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span></div>\n<p>where neighboring node features are first transformed by a weight matrix <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">Θ</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbf{\\Theta}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68611em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Θ</span></span></span></span></span></span>, normalized by their degree, and finally summed up.\nThis formula can be divided into the following steps:</p>\n<ol>\n<li>Add self-loops to the adjacency matrix.</li>\n<li>Linearly transform node feature matrix.</li>\n<li>Normalize node features.</li>\n<li>Sum up neighboring node features.</li>\n<li>Return new node embeddings.</li>\n</ol>\n<p>Pytorch Geometric provides the <code class=\"language-text\">MessagePassing</code> class, all we need to do to implement GCN is write our <code class=\"language-text\">update()</code> and <code class=\"language-text\">message()</code> functions.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">GCNConv</span><span class=\"token punctuation\">(</span>MessagePassing<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> in_channels<span class=\"token punctuation\">,</span> out_channels<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token builtin\">super</span><span class=\"token punctuation\">(</span>GCNConv<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span>aggr<span class=\"token operator\">=</span><span class=\"token string\">'add'</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># \"Add\" aggregation.</span>\n        self<span class=\"token punctuation\">.</span>lin <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>nn<span class=\"token punctuation\">.</span>Linear<span class=\"token punctuation\">(</span>in_channels<span class=\"token punctuation\">,</span> out_channels<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">forward</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> edge_index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># x has shape [N, in_channels]</span>\n        <span class=\"token comment\"># edge_index has shape [2, E]</span>\n\n        <span class=\"token comment\"># Step 1: Add self-loops to the adjacency matrix.</span>\n        edge_index <span class=\"token operator\">=</span> add_self_loops<span class=\"token punctuation\">(</span>edge_index<span class=\"token punctuation\">,</span> num_nodes<span class=\"token operator\">=</span>x<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\"># Step 2: Linearly transform node feature matrix.</span>\n        x <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>lin<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\"># Step 3-5: Start propagating messages.</span>\n        <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>propagate<span class=\"token punctuation\">(</span>edge_index<span class=\"token punctuation\">,</span> x<span class=\"token operator\">=</span>x<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">message</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> x_j<span class=\"token punctuation\">,</span> edge_index<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># x_j has shape [E, out_channels]</span>\n\n        <span class=\"token comment\"># Step 3: Normalize node features.</span>\n        row<span class=\"token punctuation\">,</span> col <span class=\"token operator\">=</span> edge_index\n        deg <span class=\"token operator\">=</span> degree<span class=\"token punctuation\">(</span>row<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dtype<span class=\"token operator\">=</span>x_j<span class=\"token punctuation\">.</span>dtype<span class=\"token punctuation\">)</span>\n        deg_inv_sqrt <span class=\"token operator\">=</span> deg<span class=\"token punctuation\">.</span><span class=\"token builtin\">pow</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span>\n        deg_inv_sqrt<span class=\"token punctuation\">[</span>deg_inv_sqrt <span class=\"token operator\">==</span> <span class=\"token builtin\">float</span><span class=\"token punctuation\">(</span><span class=\"token string\">'inf'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        norm <span class=\"token operator\">=</span> deg_inv_sqrt<span class=\"token punctuation\">[</span>row<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> deg_inv_sqrt<span class=\"token punctuation\">[</span>col<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">return</span> norm<span class=\"token punctuation\">.</span>view<span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> x_j\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> aggr_out<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># aggr_out has shape [N, out_channels]</span>\n\n        <span class=\"token comment\"># Step 5: Return new node embeddings.</span>\n        <span class=\"token keyword\">return</span> aggr_out</code></pre></div>\n<p>Note: Step 4 is done by setting <code class=\"language-text\">aggr='add'</code> when initialising <code class=\"language-text\">GCNConv</code>.</p>\n<p>Wasn’t too bad, right? PyTorch Geometric offers implementations of most popular convolutional layers and provides lots of examples. <a href=\"https://github.com/rusty1s/pytorch_geometric\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Check it out on github</a>.</p>\n<p>Now we can get our hands dirty with a real-world problem. The Cora dataset consists of 2708 scientific publications classified into one of seven classes. The citation network consists of 5429 links. Each publication in the dataset is described by a 0/1-valued word vector indicating the absence/presence of the corresponding word from the dictionary. We can create a simple model for the semi-supervised classication of each publication in the graph. Our model is constructed as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Net</span><span class=\"token punctuation\">(</span>torch<span class=\"token punctuation\">.</span>nn<span class=\"token punctuation\">.</span>Module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token builtin\">super</span><span class=\"token punctuation\">(</span>Net<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>conv1 <span class=\"token operator\">=</span> GCNConv<span class=\"token punctuation\">(</span>dataset<span class=\"token punctuation\">.</span>num_features<span class=\"token punctuation\">,</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>conv2 <span class=\"token operator\">=</span> GCNConv<span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">,</span> dataset<span class=\"token punctuation\">.</span>num_classes<span class=\"token punctuation\">)</span>\n\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">forward</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        x<span class=\"token punctuation\">,</span> edge_index<span class=\"token punctuation\">,</span> edge_weight <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">.</span>edge_index<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">.</span>edge_attr\n        x <span class=\"token operator\">=</span> F<span class=\"token punctuation\">.</span>relu<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>conv1<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> edge_index<span class=\"token punctuation\">,</span> edge_weight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        x <span class=\"token operator\">=</span> F<span class=\"token punctuation\">.</span>dropout<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> training<span class=\"token operator\">=</span>self<span class=\"token punctuation\">.</span>training<span class=\"token punctuation\">)</span>\n        x <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>conv2<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> edge_index<span class=\"token punctuation\">,</span> edge_weight<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> F<span class=\"token punctuation\">.</span>log_softmax<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> dim<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>With just 140 nodes in the training set we are able to achieve >80% classification accuracy for the rest of the nodes, the resulting classified Cora dataset looks as follows:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 850px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f4f59a95a1022ba3b4e602731b164903/ae694/cora.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 93.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAAsTAAALEwEAmpwYAAAClklEQVQ4y4VTzU8TQRTvP+HZxGg868mDUblx4KAn9KAJMXogRI2JUYgHP0jAEDWIRKMCihVQIBWrTdVEFChFa5Ua+WhZm6VQSj+22+3uzu7Mzsw628WyoMV32LzfvHkf83u/dZmmSSll33guvlJYsaBpQWaYYoihWdlcTlAAhZySs31WglCSKWbW0NbJdn9BEVRdLR9CBJ3RklOhM7VCFEDArvIiL+kSw4ahsSFYlJANmZuTbQMIsDIhPjQcHmKXFTWraoW51YWVjIRNvVgsD/GvZGtaDAQ5f8PX2vfl2Vc+tCql3nz3joZ/3e8XP08BWrlzKYRTXCLQ5rtT01l7ceRCJDH/3Bs8Ucdt35F0P1U0lXFBncl2OVKihnLpubHZt7dHH1TdrDnQfOj8QOuVJx/2HQzv3JV0v1haFBIQofVk6uCTuRk5GeTeN3nO1LZXN3Q17vH3HQlO1l8f97yKKqAoG2vrcEFDwliGiBOLbjE/KEnTqrqENDGTmxoJHG8ePnbae3XvO/ep4TZPV8+sf1Re5k0dUcY/IS4D5zEGBBcomdHAtKYlMdYhSgqCPxZt9wca7r082tlR5WnaP9ZyLtr7eL7nYarxkhGLVWSbECmdGopzd8dDl3+8ro60bBus2x28Vp/ofpRy90oDA3BhgQnA5ZAetYYpQRVMFPI+oM+l8zMR39mJ7pO++sOR/g7AzSqfPlJRtG7LsmvTkig1IBQxFlh7S15QyU938JO3ErFvUjymFSU2FdV1W2sbVkXIKoSLZdYxUjQli7IRPftTNzCFkKiqoxdd74xxBsIZpq4/C2cniBBMDYCRaomelsRNyN/aZg9mLzGcr8CGXlbO//9nWyxrnqESXTC3tM2ErQMkU4y2Tv4NwHgU4kQrgNIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Cora dataset\"\n        title=\"Cora dataset\"\n        src=\"/static/f4f59a95a1022ba3b4e602731b164903/ae694/cora.png\"\n        srcset=\"/static/f4f59a95a1022ba3b4e602731b164903/63868/cora.png 250w,\n/static/f4f59a95a1022ba3b4e602731b164903/0b533/cora.png 500w,\n/static/f4f59a95a1022ba3b4e602731b164903/ae694/cora.png 850w\"\n        sizes=\"(max-width: 850px) 100vw, 850px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<em>Figure 2: Semi-supervised node classification result on Cora dataset.</em></p>\n<p>It shows that Geometric Deep Learning is an elegant and performant approach when dealing with non-Euclidean structures.</p>\n<hr>\n<h3 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h3>\n<p>[1] Bronstein, Michael M., et al. “Geometric deep learning: going beyond euclidean data.” IEEE Signal Processing Magazine 34.4 (2017): 18-42.</p>\n<p>[2] Monti, Federico, Michael Bronstein, and Xavier Bresson. “Geometric matrix completion with recurrent multi-graph neural networks.” Advances in Neural Information Processing Systems. 2017.</p>\n<p>[3] Gainza, Pablo, et al. “Deciphering interaction fingerprints from protein molecular surfaces using geometric deep learning.” Nature Methods 17.2 (2020): 184-192.</p>\n<p>[4] <a href=\"https://twitter.com/fabula_ai\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">twitter.com/fabula_ai</a></p>\n<p>[5] Veselkov, Kirill, et al. “HyperFoods: Machine intelligent mapping of cancer-beating molecules in foods.” Scientific reports 9.1 (2019): 1-12.</p>\n<p>[6] Kipf, Thomas N., and Max Welling. “Semi-supervised classification with graph convolutional networks.” arXiv preprint arXiv:1609.02907 (2016).</p>\n<p>[7] Fey, Matthias, and Jan Eric Lenssen. “Fast graph representation learning with PyTorch Geometric.” arXiv preprint arXiv:1903.02428 (2019).</p>","timeToRead":8,"frontmatter":{"title":"Geometric Deep Learning - an overview","date":"June 10, 2020","spoiler":"Series of posts covering learnings from my MEng thesis \"Geometric Deep Learning for Subcortical Brain Shape Analysis\".","cta":"gdl","ogimage":null},"fields":{"slug":"/geometric-deep-learning-overview/","langKey":"en"}}},"pageContext":{"slug":"/geometric-deep-learning-overview/","previous":{"fields":{"slug":"/cycling-in-london/","langKey":"en","directoryName":"cycling-in-london","maybeAbsoluteLinks":""},"frontmatter":{"title":"My take on cycling in London"}},"next":{"fields":{"slug":"/bikepacking-in-sweden/","langKey":"en","directoryName":"bikepacking-in-sweden","maybeAbsoluteLinks":""},"frontmatter":{"title":"Bikepacking & wild camping in Sweden"}},"translations":[],"translatedLinks":[]}},
    "staticQueryHashes": ["4190863273"]}